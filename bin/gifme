#!/bin/bash

set -e

function usage() 
{
cat << EOF
Usage: gifme [options] FILES

Supported options:

    -o /path/to/output  Set the animation\'s output directory
    -d DELAY            Set the delay between frames (default: 20)
    -w PIXELS           Set the width of the image (default is 500px)
    -i NUMBER           Use the iSight camera (2 second delay per capture)
    -r                  Reverse the GIF to make it loopable
    -h                  Show this message

EOF
}

TIMESTAMP=$(date +%F_%Hh-%Mm-%Ss)
OUTPUT="${HOME}/Desktop/animated-${TIMESTAMP}.gif"
DELAY=20
WIDTH=500
DROP=$(which drop 2>&1 > /dev/null) || DROP=""

GIFME="/tmp/gifme"

while getopts ":o:rd:w:i:h" opt; do
    case $opt in
        o)
        OUTPUT=$OPTARG
        ;;
        r)
        REVERSE=true
        ;;
        d)
        DELAY=$OPTARG
        ;;
        w)
        WIDTH=$OPTARG
        ;;
        i)
        ISIGHT=$OPTARG
        ;;
        h)
        usage
        exit 0
        ;;
        \?)
        echo "Invalid option: -$OPTARG" >&2
        ;;
        :)
        echo "Option -$OPTARG requires an argument." >&2
        exit 1
        ;;
    esac
done
shift $(($OPTIND-1))
CONVERT_ARGS="-loop 0 -layers OptimizeTransparency -delay $DELAY -resize $WIDTH"

if [ -z $(which convert) ]; then
    echo "You need to install ImageMagick first."
    echo
    echo "If you're on a Mac, this should be as easy as:"
    echo "  brew install imagemagick"
    exit 1
fi

if [ -z $(which imagesnap) ]; then
    echo "You need to install ImageSnap first."
    echo
    echo "If you're on a Mac, this should be as easy as:"
    echo "  brew install imagesnap"
    exit 1
fi

[ -d $GIFME ] && rm -Rf ${GIFME}
mkdir -p ${GIFME}
idx=1

if [ ! -z $ISIGHT ]; then
    echo "You have 2 seconds to prepare yourself!"
    while [ "$idx" -le "$ISIGHT" ]; do
        echo "counting down... 2"
        sleep 1
        echo "counting down... 1"
        sleep 1
        echo "Taking iSight snapshot $idx of $ISIGHT"
        imagesnap ${GIFME}/frame-${idx}.jpg
        idx=$((idx + 1))
    done   
fi

echo $@
for files in $@
do
    [ "$files" = "--" ] && continue
    file_name="frame-$idx"
    if [ "${files:0:4}" = "http" ]; then
        wget $files -O ${GIFME}/${file_name}
        pushd /tmp/gifme > /dev/null
        convert ${GIFME}/${file_name} -coalesce frame_%03d.gif
        popd > /dev/null
    else
        cp $files $GIFME/${file_name}
    fi
    idx=$((idx + 1))
done

pushd /tmp/gifme > /dev/null
FILE=()
FILE_REVERSE=()
for f in $GIFME/*
do
    FILE=("${FILE[@]}" "$f")
    FILE_REVERSE=("$f" "${FILE_REVERSE[@]}")
done

if $REVERSE ; then
    FILE=("${FILE[@]}" "${FILE_REVERSE[@]}")
fi
convert ${CONVERT_ARGS} ${FILE[@]} $OUTPUT

if [ $? -eq 0 ]; then
    echo "You now have a handsome animation at $OUTPUT"
else
    echo "Something broke when we were animating your gif. Shit."
    exit 1 
fi
popd > /dev/null

[ -d $GIFME ] && rm -Rf ${GIFME}

if [ ! -z $DROP ]; then
    echo "Now we're uploading it to Drop"
    $DROP $OUTPUT
fi

exit 0



